type X<A> = Y<A>;
type Y<C> = {x: C} & {y: String} & { y: String } | String | Z;
type Z = String | Int | Lol | Lol2<Int>;

type L1<X> = L2<X>;
type L2<Z> = Z;

struct Lol {
    o: &Lol | .none,
} impl {
    fn abc() {
        // const x: Int = "a";
    }
}

extend String with impl {
    fn len() -> Int {
        const a: Z = 100;
    }
}

struct Lol2<T> {
    x: T,
} impl {
    fn lol<X>(x: X) {

    }
}

fn main() {
    const l: Lol = Lol {
        o: .none
    };
    b<String>("abc").lol<Int>(10);
    c<Int | Bool>();
}

fn b<T>(x: T) -> Lol2<T> {
    Lol2<T> {
        x: x,
    }
}

fn c<T>() -> T | String {
}

fn a() -> X<Float> {}
