type X<A> = Y<A>;
type Y<C> = {x: C} & {y: String} & { y: String } | String | Z;
type Z = String | Int | Lol | Lol2<Int>;

type L1<X> = L2<X>;
type L2<Z> = Z;

struct Lol {}
struct Lol2<T> {
    x: T,
} impl {
    fn lol<X>(x: X) {

    }
}

fn main() {
    b<String>("abc").lol<Int>(10);
    c<Int | Bool>();
}

fn b<T>(x: T) -> Lol2<T> {
    Lol2<T> {
        x: x,
    }
}

fn c<T>() -> T | String {
}

fn a() -> X<Float> {}
