type O = { x: String };
type X<A> = B<Int, A>;
type B<Z, ZZ> = C<O, ZZ, Float, Z>;

struct Other<UUU> = {s: UUU} impl {
    fn lol() -> Other<UUU> {
        return { let x: Other<UUU> = Other<UUU>{s: self.s}; x.s->std::io::println(); x};
    }
};

struct C<T, E, U, I> = {
    f: E,
} impl {
    fn get_f() -> Other<E> {
        return Other<E>{s: self.f};
    }

    fn get_x<X2>(x: X2) -> X2 {
        return x;
    }
};

fn extract(s: Other<String>) -> String {
    return s.s;
}

fn gen_method<EE>(s: Other<EE>, x: Bool) -> EE {
    if (x) {
        return s.s;
    } else {
        return gen_method<EE>(s, true);
    }
}

fn main() {
    let a: X<String> = X<String>{f: "hallo"};
    a.get_f().lol().s->std::io::println();
    a.get_f().lol()->gen_method<String>(false)->std::io::println();
}
