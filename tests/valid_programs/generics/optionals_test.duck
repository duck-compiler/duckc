use std::io::{debug, println};

struct Option<T> {
    inner: T | .empty,
} impl {
    fn filter(f: fn(x: T) -> Bool) -> Option<T> {
        return match self.inner {
            T @ value => if (f(value)) { *self } else { empty_Option<T>() },
            .empty => empty_Option<T>(),
        };
    }

    fn map<U>(f: fn(x: T) -> U) -> Option<U> {
        return match self.inner {
            T @ value => some<U>(f(value)),
            .empty => empty_Option<U>(),
        };
    }

    fn is_empty() -> Bool {
        return match self.inner {
            T => false,
            .empty => true,
        };
    }

    fn is_some() -> Bool {
        return !self.is_empty();
    }

    fn zip<U>(other: Option<U>) -> Option<(T, U)> {
        return match self.inner {
            T @ first => match other.inner {
                U @ second => some<(T, U)>((first, second)),
                .empty => empty_Option<(T, U)>(),
            },
            .empty => empty_Option<(T, U)>(),
        };
    }

    fn unwrap() -> T {
        match self.inner {
            T @ val => return val,
            .empty => std::error::panic("empty optional"),
        }
    }

    fn expect(s: String) -> T {
        match self.inner {
            T @ val => return val,
            .empty => std::error::panic(s),
        }
    }
}

fn empty_Option<T>() -> Option<T> {
    return Option<T> { inner: .empty };
}

fn some<T>(v: T) -> Option<T> {
    return Option<T> { inner: v };
}

fn main() {
    let v: String = "abc";

    let o: Option<String> = some<String>("Yo");
    let o2: Option<Int> = some<Int>(200);

    debug(o.filter(fn(x: String) -> Bool { return false; }).is_empty());
    debug(o.filter(fn(x: String) -> Bool { return true }).inner.to_string());
    debug(o.filter(fn(x: String) -> Bool { return false }).inner.to_string());
    debug(o.map<Int>(fn(x: String) -> Int { return 100 }).inner.to_string());
    debug(o.map<Int>(fn(x: String) -> Int { return 100 }).is_empty());
    debug(o.map<Int>(fn(x: String) -> Int { return 100 }).is_some());
    debug(o.zip<Int>(o2).inner.to_string());
    debug(o.zip<Int>(o2).is_some());
    debug(o.zip<Int>(empty_Option<Int>()).is_empty());
    debug(empty_Option<String>().unwrap().to_string());
}
