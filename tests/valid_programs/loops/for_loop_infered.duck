struct b {} impl {
    fn a() -> Int[] {
       return [1, 2, 30];
    }
}

struct ContainsArray {
    a: Int[],
}

fn take_array_ref(a: &Int[]) {
    for (i in b {}.a().iter()) {
        std::io::println(std::string::from_int(*i));
    }
    std::io::println("fisch");
}

fn take_array_mut(a: &mut Int[]) {
    for (i in a.iter()) {}
}

fn take_array_mut2(a: &mut Int[]) {
    for (i in a.iter()) {}
    for (i in a.iter_mut()) {}
    for (i in a.iter()) {}
    for (i in a.iter_mut()) {}
    const x = 10;
    const x = 10;
    for (i in a.iter()) {}
    const x = 10;
    for (i in a.iter()) {}
    for (i in a.iter_mut()) {}
    const x = 10;
}

fn take_array_in_tuple(t: (&Int[],)) {
    for (i in t.0.iter()) {

    }
}

fn take_array_in_duck(t: { x: &Int[] }) {
    for (i in t.x.iter()) {

    }
}

fn take_array(a: Int[]) {
    for (i in a.iter()) {

    }
}

fn takes_lambda(f: fn(x: Int, y: String) -> String) {
    std::io::println(f(10, "yooo"));
}

fn takes_lambda2(f: fn(x: Int, y: String) -> String[]) {
    f(10, "yooo");
}

fn main() {
    const x: Int[] = [];
    const x2 = ContainsArray { a: [] };

    takes_lambda(fn(x, y) {
        f"y = {y}, x = {std::string::from_int(x)}"
    });
    takes_lambda2(fn(x, y) {
        []
    });
    take_array_ref(&[]);
    take_array_mut(&mut []);
    take_array([]);
    take_array_in_tuple((&[],));
    take_array_in_duck(if (true) { { x: &[], } } else { { x: &[], } });
}
