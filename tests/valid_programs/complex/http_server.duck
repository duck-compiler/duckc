use go "net/http";

fn __render(renderer: Html) -> String {
    go {
	    env := TemplEnv{[]string{}, []RenderCall{}}
		res := renderer(&env)

		prelude := `
            <script type="module">
            import { h, render } from "https://esm.sh/preact";
            import { useState } from "https://esm.sh/preact/hooks";
            import htm from "https://esm.sh/htm";

            // Initialize htm with Preact
            const html = htm.bind(h);
        `

        for _, e := range env.ClientComponents {
            prelude += e
            prelude += "\n"
        }

        for _, e := range env.RenderCalls {
            prelude += fmt.Sprintf("document.querySelectorAll(\"[duckx-render=\\\"%s\\\"]\").forEach(e => render(html`%s`, e))", e.Id, e.Jsx)
            prelude += "\n"
        }

        prelude += "\n</script>"

		return res + prelude
    }

    return ""
}

component ExampleComponent(props: { name: String }) jsx {
    return (
        <>
            <span>Hallo</span>
        </>
    )
}

template ExampleTemplate(props: { my_props: String }) duckx {
    return (
        <>
            <!doctype html>
            <html>
                <head>
                    <title>Duck Page</title>
                </head>
                <body>
                    <h1>HIII {props.my_props}</span>
                </body>
            </html>
        </>
    )
}

type LogLevel = .verbose | .none;

type RenderedJsx = (
    String,
    String,
);

type JsxComponent<P> = mut fn (props: P) -> RenderedJsx;

struct Request {
    request_ref: &go "http.Request",
} impl {
    fn header(name: String) -> String | .none {
        go {
            value := (*self).request_ref.Header.Get(name)
            if value == "" {
            	return &Tag__none {}
            }

            return &value;
        };

        return .none;
    }


    /// reads the value of query param ?<name>=<value> from given request url in self.request_ref.URL
    fn query_param(name: String) -> String | .none {
        go {
            value := (*self).request_ref.URL.Query().Get(name)
            if value == "" {
                return &Tag__none { }
            }
            return &value
        }
    }

    fn body_str() -> String | .err {
        go {
            bodyBytes, err := ioutil.ReadAll((*self).request_ref.Body)
            if err != nil {
            	return &Tag__err { }
            }

            (*self).request_ref.Body = ioutil.NopCloser(bytes.NewBuffer(bodyBytes))
            body_str := string(bodyBytes)
             return &body_str
        } as !
    }

    fn json<T: {}>() -> T | .err {
        const body = match self.body_str() {
            String @str => str,
            else => return .err,
        };

        return parse_json<T>(body)
    }

    fn cookie(name: String) -> Cookie | .none {
        const cookie: &go "http.Cookie" = go {
            $, err := (*self).request_ref.Cookie(name)
            if err != nil {
            	return &Tag__none {}
            }
        };

        return Cookie::from_go_cookie(cookie);
    }
}

struct Cookie {
    fname: String,
    fvalue: String,
    fquoted: Bool,
    fpath: String,
    fdomain: String,
    fexpires: std::time::Time | .none,
    fraw_expires: String,
    fmax_age: Int,
    fsecure: Bool,
    fhttp_only: Bool,
    fsame_site: .default | .lax | .strict | .none,
    fpartitioned: Bool,
    fraw: String,
    funparsed: String[],
} impl {
    static fn new(name: String, value: String) -> Cookie {
        return Cookie {
            fname: name,
            fvalue: value,
            fquoted: false,
            fpath: "",
            fdomain: "",
            fexpires: .none,
            fraw_expires: "",
            fmax_age: 0,
            fsecure: false,
            fhttp_only: false,
            fsame_site: .default,
            fpartitioned: false,
            fraw: "",
            funparsed: [],
        };
    }

    static fn from_go_cookie(go_cookie: &go "http.Cookie") -> Cookie {
        let name: String;
        let value: String;
        let quoted: Bool;
        let p: String;
        let domain: String;
        let expires: std::time::Time | .none;
        let raw_expires: String;
        let max_age: Int;
        let secure: Bool;
        let http_only: Bool;
        let same_site: .default | .lax | .strict | .none;
        let partitioned: Bool;
        let raw: String;
        let unparsed: String[];

        go {
            name = go_cookie.Name
            value = go_cookie.Value
            quoted = go_cookie.Quoted
            p = go_cookie.Path
            domain = go_cookie.Domain
            if go_cookie.Expires.IsZero() {
            	expires = Tag__none {}
            } else {
            	expires = go_cookie.Expires
            }

            max_age = go_cookie.MaxAge
            secure = go_cookie.Secure
            http_only = go_cookie.HttpOnly
            switch go_cookie.SameSite {
            	case http.SameSiteDefaultMode:
             		same_site = Tag__default {}
             	case http.SameSiteLaxMode:
              		same_site = Tag__lax {}
              	case http.SameSiteStrictMode:
               		same_site = Tag__strict {}
               	case http.SameSiteNoneMode:
                	same_site = Tag__none {}
            }

            partitioned = go_cookie.Partitioned
            raw = go_cookie.Raw
            unparsed = go_cookie.Unparsed
        };

        return Cookie {
            fname: name,
            fvalue: value,
            fquoted: quoted,
            fpath: p,
            fdomain: domain,
            fexpires: expires,
            fraw_expires: raw_expires,
            fmax_age: max_age,
            fsecure: secure,
            fhttp_only: http_only,
            fsame_site: same_site,
            fpartitioned: partitioned,
            fraw: raw,
            funparsed: unparsed,
        }
    }

    fn to_go_cookie() -> &go "http.Cookie" {
        let expires: go "time.Time" = go {
            if ((*self).fexpires == Tag__none {}) {
            	$ = time.Time {}
            } else {
            	t, okkk := (*self).fexpires.(time.Time);
             	if okkk {
             		$ = t
              	} else {
               		$ = time.Time {}
               	}
            }
        };

        let same_site: go "http.SameSite" = match self.fsame_site {
            .default => go { $ = http.SameSiteDefaultMode } as go "http.SameSite",
            .lax => go { $ = http.SameSiteLaxMode } as go "http.SameSite",
            .strict => go { $ = http.SameSiteStrictMode } as go "http.SameSite",
            .none => go { $ = http.SameSiteNoneMode } as go "http.SameSite",
        } as go "http.SameSite";

        let go_cookie: go "http.Cookie" = go {
            cookie := http.Cookie {}
            cookie.Name = (*self).fname;
            cookie.Value = (*self).fvalue;
            cookie.Path = (*self).fpath;
            cookie.Domain = (*self).fdomain;
            cookie.Expires = expires;
            cookie.RawExpires = (*self).fraw_expires;
            cookie.MaxAge = (*self).fmax_age;
            cookie.Secure = (*self).fsecure;
            cookie.HttpOnly = (*self).fhttp_only;
            cookie.SameSite = same_site;
            cookie.Partitioned = (*self).fpartitioned;
            cookie.Raw = (*self).fraw;
            cookie.Unparsed = (*self).funparsed;

            $ = cookie
        } as go "http.Cookie";

        return &go_cookie;
    }

    mut fn http_only(enabled: Bool) -> &mut Cookie {
        self.fhttp_only = enabled;
        return self;
    }
}

struct Response {
    writer: &go "http.ResponseWriter",
} impl {
    fn status(code: Int) -> &Response {
        go {
            (*(*self).writer).WriteHeader(int(code))
        }
        return self;
    }

    fn header(key: String, value: String) -> &Response {
        go {
            (*(*self).writer).Header().Set(key, value)
        }
        return self;
    }

    mut fn set_cookie(cookie: &Cookie) -> &Response {
        let go_cookie = cookie.to_go_cookie();
        go {
            http.SetCookie(*(*self).writer, go_cookie)
        }
        return self;
    }

    fn str(content: String) {
        go {
            (*(*self).writer).Write([]byte(content))
        }
    }

    fn json<T: {}>(body: T) {
        self.header("Content-Type", "application/json");
        let jso = body.to_json();
        go {
            (*(*self).writer).Write([]byte(jso))
        }
    }

    fn json_str(str: String) {
        self.header("Content-Type", "application/json")
            .str(str);
    }

    fn duckx(templ: Html) {
        self.str(__render(templ))
    }
}

struct HttpServer {
    mux: &go "http.ServeMux",
    log_level: LogLevel,
} impl {
    static fn new(log_level: LogLevel) -> HttpServer {
        let mux: &go "http.ServeMux" = go {
            $ = http.NewServeMux()
        };

        return HttpServer {
            mux: mux,
            log_level: log_level,
        }
    }

    fn handle(route: String, handler: fn(req: Request, res: &mut Response)) -> &HttpServer {
        self.log(f"handling route {route}");
        const handle_fn = fn (response_writer: go "http.ResponseWriter", request: &go "http.Request") {
            let req = Request { request_ref: request };
            let res = Response { writer: &response_writer };
            handler(req, &mut res);
        };

        go {
            (*self).mux.HandleFunc(route, func (w http.ResponseWriter, r *http.Request) { handle_fn(w, r) } )
        }
        return self;
    }

    fn serve_component(
        route: String,
        rendered: RenderedJsx,
    ) -> &HttpServer {
        let with_react = self.__with_react;
        go {
            (*self).mux.HandleFunc(route, func (w http.ResponseWriter, r *http.Request) {
                w.Write([]byte(with_react(rendered)))
            })
        }

        return self;
    }

    fn serve_dynamic_component<P>(
        route: String,
        jsx_component: JsxComponent<P>,
        prop_supplier: mut fn () -> P,
    ) -> &HttpServer {
        let with_react = self.__with_react;
        go {
            (*self).mux.HandleFunc(route, func (w http.ResponseWriter, r *http.Request) {
                var jsx = jsx_component(prop_supplier());
                w.Write([]byte(with_react(jsx)))
            })
        }

        return self;
    }

    fn serve_template(route: String, templ: Html) -> &HttpServer {
        let render = __render;
        go {
            (*self).mux.HandleFunc(route, func (w http.ResponseWriter, r *http.Request) {
                w.Write([]byte(render(templ)))
            })
        }

        return self;
    }

    fn __with_react(
        rendered_jsx: RenderedJsx
    ) -> String {
        let layout: String = f"
            <!DOCTYPE html>
            <html>
                <body>
                    <script type='module'>
                        import \{ h, render } from 'https://esm.sh/preact';
                        import \{ useState } from 'https://esm.sh/preact/hooks';
                        import htm from 'https://esm.sh/htm';

                        const html = htm.bind(h);

                        {rendered_jsx.1}
                        render(html`<$\{{rendered_jsx.0}} />`, document.body);
                    </script>
                </body>
            </html>
        ";

        return layout;
    }

    fn listen(bind: String) {
        self.log(f"binding to {bind}");
        go {
            http.ListenAndServe(bind, (*self).mux)
        }
    }

    fn log(msg: String) {
        if (self.log_level == .verbose) {
            std::io::println(f"{" http-server ".on_red()} {msg}");
        }
    }
}

fn main() {
    let server = HttpServer::new(.verbose);
    async server
        .handle("GET /hello", fn (req: Request, res: &mut Response) {
            res.set_cookie(&Cookie::new("hallo", "welt"));
            let user_agent = req.header("User-Agent");
            res
                .status(200)
                .json_str("[\"hello\"]");
        })
        .handle("GET /duckx", fn (req: Request, res: &mut Response) {
            res.set_cookie(&Cookie::new("hallo", "welt"));
            let user_agent = req.header("User-Agent");
            res
                .status(200)
                .duckx(ExampleTemplate({ my_props: "whaaat" }))
        })
        .handle("POST /post", fn (req: Request, res: &mut Response) {
            res
                .json({
                    x: "hello",
                });
        })
        .serve_component("/component", ExampleComponent({ name: "yooo" }))
        .serve_dynamic_component<{ name: String }>("/other", ExampleComponent, fn () -> { name: String } {
            return { name: "yoo"}
        })
        .serve_template("/stat", ExampleTemplate({ my_props: "yoo" }))
        .listen(":8080");

    std::task::sleep(std::time::Duration::seconds(1));

    let hello_response = std::web::fetch(.GET, "http://localhost:8080/hello").send();
    std::assert(hello_response == "[\"hello\"]", "didn't receive what we sent :(");

    let post_response: String = match std::web::fetch(.POST, "http://localhost:8080/post").send() {
        String @str => str,
        else => std::error::panic("could send post"),
    };

    let parsed_response = post_response->parse_json<{ x: String }>();
    std::assert(parsed_response != .err, "couldn't parse json from post response");

    match parsed_response {
        { x: String } @parsed => {
            std::assert(parsed.x == "hello", "response.x is not hello");
        },
        .err => std::error::panic("something is completely fck"),
    };

    std::assert(std::web::fetch(.GET, "http://localhost:8080/post").send().to_string().trim() == "Method Not Allowed", "get against post worked :(");
    std::io::println("everythings great!");
}
