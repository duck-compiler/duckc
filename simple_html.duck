module html_mod;
use html_mod::give_me_something;

use std::lol;

component test_component(props: {x: Int}) jsx {
    return (<>
      <h1>x = {props.x}</h1>
      <lol/>
      <give_me_something x={props.x}/>
    </>);
}

component inside_counter() jsx {
    return (
      <div style="border: 2px solid red">
          <button onClick={() => props.cb()}>Call callback</button>
      </div>
    );
}

component comp_with_ssr_props(props: { a: Int, b: Float, c: Bool, d: Char, e: UInt, f: String, g: UInt[] }) jsx {
    return (
      <div style="border: 2px solid red">
          <ol>
            <li>a: {props.a}</li>
            <li>b: {props.b}</li>
            <li>c: {props.c}</li>
            <li>d: {props.d}</li>
            <li>e: {props.e}</li>
            <li>f: {props.f}</li>
            <li>g: {props.g}</li>
          </ol>
      </div>
    );
}

template ssr_no_params() duckx {
    <p>No params</p>
}

component counter(props: { name: String, initial_value: Int, inc_text: { inc_text: String } }) jsx {
    const [count, setCount] = useState(props.initial_value);
    const inc = () => setCount(count + 1);
    const inc2 = () => setCount(count + 30);
    return (
      <div style="border: 2px solid">
          <p>Counter Name: {props.name}</p>
          <p>Counter Value: {count}</p>
          <button onClick={inc}>{props.inc_text.inc_text}</button>
          <inside_counter cb={() => {
            setCount(count + 30);
          }}/>
      </div>
    )
}

template other_ssr(props: { color: String }) duckx {
    <span style="color: {props.color};">hello from other ssr</span>
}

template ssr(props: {x: Int}) duckx {
        <>
        <!DOCTYPE html>
        <html>
            <head>
                <title>hello from duck server side rendering</title>
                <meta charset="utf-8"/>
            </head>
            <body>
                <p>Duck expressions:
                    <ul>
                        <li>{1}</li>
                        <li>{1.3}</li>
                        <li>{2 as UInt}</li>
                        <li>{true}</li>
                        <li>{"i am a string"}</li>
                        <li>{<span style="color: green;">nested html expr</span>}</li>
                        <li>{<span style="color: green;">nested {"html"} expr {{"no. 2"}}</span>}</li>
                    </ul>
                </p>
                <p>Other Duckx:
                    <ul>
                        <other_ssr color={"red"}/>
                        <br/>
                        <other_ssr color={"blue"}/>
                    </ul>
                </p>
                <p>JSX:
                    <counter name={"I am a jsx based counter inside a server side rendered component"} initial_value={10} inc_text={{inc_text: "Increment"}}/>
                    <counter name={"I am another counter"} initial_value={20} inc_text={{inc_text: "Click me"}}/>
                    <counter name={"Counter no. 3"} initial_value={30} inc_text={{inc_text: "Click me"}}/>
                    <comp_with_ssr_props a={10} b={3.4} c={true} d={'d'} e={30} f={"f"} g={[323] as UInt[]}/>
                    <inside_counter/>
                    <ssr_no_params/>
                    <inside_counter />
                    <ssr_no_params/>
                    <inside_counter/>
                    <ssr_no_params />
                    <inside_counter  />
                    <ssr_no_params   />
                </p>
            </body>
        </html>
    </>
}

fn main() {
    const x = inside_counter({});
    std::http::serve_component("/jsx", test_component, fn() -> { x: Int } { {x: 100} });
    std::http::serve_component("/cl_ssr", comp_with_ssr_props, fn() -> { a: Int, b: Float, c: Bool, d: Char, e: UInt, f: String, g: UInt[] } {
        {
            a: 10,
            b: 11.5,
            c: true,
            d: 'd',
            e: 13,
            f: "f",
            g: [12333339],
        }
    });
    std::http::serve_string("/", std::http::render(ssr({x: 1})));
    std::http::listen(8080);
}
