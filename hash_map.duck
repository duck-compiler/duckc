use std::{Opt};

fn array_for<E>(arr: E[], f: fn(e: E, i: Int) -> Bool) {
    go {
        for i, e := range arr {
            if !f(e, i) {
                break
            }
        }
    }
}

 type KV<K, V> = (K, V);

struct HashMap<K, V> = {
    hash_fn: fn(k: K) -> Int,
    eq_fn: fn(k1: K, k2: K) -> Bool,
    buffer: Opt<Bucket<Int, Int>>[],
    _len: Int,
} impl {
    mut fn insert(k: K, v: V) {
        const hash = self.hash_fn(k);
        const pos = hash % self.capacity();

        match self.buffer[pos] {
            .none => {
                let val = .(K, V)[(k, v)];
                go {
                (*self).buffer[pos] = val
                }
                self._len = self._len + 1;
                break;
            },
            (K, V)[] @kv => {
                self._len = self._len + 1;
                let found: Opt<Int> = .none;
                array_for<(K, V)>(kv, mut fn (elem: (K, V), i: Int) -> Bool {
                    if (self.eq_fn(elem.0, k)) {
                        found = i;
                        return false;
                    }
                    return true;
                });

                match found {
                    .none => {
                        const val = (k, v);
                        go {
                            kv = append(kv, val)
                        }
                    },
                    Int @found_idx => kv[found_idx] = (k, v),
                }
            },
        }
    }

    mut fn remove(k: K) -> Bool {
        let result = false;

        go {
            var var_34 any
            _ = var_34
        }

        if (self.capacity() > 0) {
            const hash = self.hash_fn(k);
            const pos = hash % self.capacity();
            let total_delete = false;
            match self.buffer[pos] {
                .none => {},
                (K, V)[] @kv => {
                    self._len = self._len + 1;
                    let found: Opt<Int> = .none;
                    array_for<(K, V)>(kv, mut fn (elem: (K, V), i: Int) -> Bool {
                        if (self.eq_fn(elem.0, k)) {
                            found = i;
                            return false;
                        }
                        return true;
                    });

                    match found {
                        .none => {},
                        Int @found_idx => {
                            let res = .KV<K, V>[];
                            go {
                                if len(kv) == 1 {
                                    total_delete = true
                                } else {
                                    if found_idx == 0 {
                                        res = kv[found_idx+1:]
                                    } else if found_idx == len(kv) - 1 {
                                        res = kv[:found_idx]
                                    } else {
                                        res = kv[:found_idx]
                                        for _, e := range kv[found_idx+1:] {
                                            res = append(res, e)
                                        }
                                    }
                                }
                            }
                            if (!total_delete) {
                                go {
                                    (*self).buffer[pos] = res;
                                }
                            }
                        }
                    }
                },
            }
            if (total_delete) {
                self.buffer[pos] = .none;
            }
        }

        return result;
    }

    fn len() -> Int {
        return self._len;
    }

    fn capacity() -> Int {
        let cap: Int = 0;
        go {
            cap = len((*self).buffer)
        }
        return cap;
    }

    fn for_each(f: fn(k: K, v: V)) {
        const extract = fn(o: Opt<Bucket<K, V>>) {
            match o {
                .none => {},
                (K, V)[] @kv => {
                    go {
                        for _, e := range kv {
                            f(e.field_0, e.field_1)
                        }
                    }
                },

            }
        };
        go {
            for _, e := range (*self).buffer {
                switch e.(type) {
                case Tag__none:
                    continue;
                default:
                    extract(e)
                }
            }
        }
    }
};

type Bucket<K, V> = (K, V)[];

fn main() {
    let m = HashMap<Int, Int> {
        hash_fn: fn(x: Int) -> Int { x },
        eq_fn: fn(x: Int, y: Int) -> Bool {x == y},
        buffer: .Opt<Bucket<Int, Int>>[.none, .none, .none, .none],
        _len: 0
    };
    m.insert(1000, 2);
    m.insert(2, 5);
    m.insert(5, 1000);
    m.insert(1000, 5);
    m.for_each(fn (k: Int, v: Int) {
        std::io::println(f"{std::string::from_int(k)} -> {std::string::from_int(v)}");
    });
    if (m.remove(2)) {
        std::io::println("true");
    } else {
        std::io::println("false");
    }
    m.for_each(fn (k: Int, v: Int) {
        std::io::println(f"{std::string::from_int(k)} -> {std::string::from_int(v)}");
    });
}
