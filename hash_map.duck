use std::{Opt};

fn array_for<E>(arr: E[], f: fn(e: E, i: Int) -> Bool) {
    go {
        for i, e := range arr {
            if !f(e, i) {
                break
            }
        }
    }
}

 type KV<K, V> = (K, V);

 struct BigInt = {
     v: Int,
 } impl {
     fn eq(other: &BigInt) -> Bool {
         return self.v == other.v;
     }

     fn hash() -> Int {
         return self.v;
     }
 };

struct HashMap<K: { eq: fn(other: &K) -> Bool, hash: fn() -> Int }, V> = {
    buffer: Opt<Bucket<K, V>>[],
    _len: Int,
} impl {
    mut fn insert(k: K, v: V) {
        const hash = k.hash();
        const pos = hash % self.capacity();

        match self.buffer[pos] {
            .none => {
                let val = [(k, v)];
                go {
                	(*self).buffer[pos] = val
                }
                self._len = self._len + 1;
                break;
            },
            (K, V)[] @kv => {
                self._len = self._len + 1;
                let found: Opt<Int> = .none;
                array_for<(K, V)>(kv, mut fn (elem: (K, V), i: Int) -> Bool {
                    if (elem.0.eq(&k)) {
                        found = i;
                        return false;
                    }
                    return true;
                });

                match found {
                    .none => {
                        const val = (k, v);
                        go {
                            kv = append(kv, val)
                        }
                    },
                    Int @found_idx => kv[found_idx] = (k, v),
                }
            },
        }
    }

    mut fn remove(k: K) -> Bool {
        let result = false;

        if (self.capacity() > 0) {
            const hash = k.hash();
            const pos = hash % self.capacity();
            let total_delete = false;
            match self.buffer[pos] {
                .none => {},
                (K, V)[] @kv => {
                    let found: Opt<Int> = .none;
                    array_for<(K, V)>(kv, mut fn (elem: (K, V), i: Int) -> Bool {
                        if (elem.0.eq(&k)) {
                            found = i;
                            return false;
                        }
                        return true;
                    });

                    match found {
                        .none => {},
                        Int @found_idx => {
                            let res = [:KV<K, V>];

                            go {
                                if len(kv) == 1 {
                                    total_delete = true
                                } else {
                                    if found_idx == 0 {
                                        res = kv[found_idx+1:]
                                    } else if found_idx == len(kv) - 1 {
                                        res = kv[:found_idx]
                                    } else {
                                        res = kv[:found_idx]
                                        for _, e := range kv[found_idx+1:] {
                                            res = append(res, e)
                                        }
                                    }
                                }
                            }
                            if (!total_delete) {
                                go {
                                    (*self).buffer[pos] = res;
                                }
                            }
                        }
                    }
                },
            }
            if (total_delete) {
                self.buffer[pos] = .none;
            }
        }

        return result;
    }

    fn len() -> Int {
        return self._len;
    }

    fn capacity() -> Int {
        let cap: Int = 0;
        go {
            cap = len((*self).buffer)
        }
        return cap;
    }

    fn for_each(f: fn(k: &K, v: &V)) {
        for kv in &self.buffer {
            match *kv {
                .none => {},
                (K, V)[] @bucket => {
                    for kv in &bucket {
                        f(&kv.0, &kv.1);
                    }
                }
             }
        }
    }

    mut fn for_each_mut(f: fn(k: &K, v: &mut V)) {
        for kv in &self.buffer {
            match *kv {
                .none => {},
                (K, V)[] @bucket => {
                    for kv in &bucket {
                        f(&kv.0, &mut kv.1);
                    }
                }
             }
        }
    }
};

type Bucket<K, V> = (K, V)[];

fn main() {
    let m = HashMap<BigInt, Int> {
        buffer: [:Opt<Bucket<BigInt, Int>>, .none, .none, .none, .none],
        _len: 0
    };
    m.insert(BigInt { v: 1000 }, 2);
    m.insert(BigInt { v: 2 }, 5);
    m.insert(BigInt { v: 5 }, 1000);
    m.insert(BigInt { v: 1000 }, 5);
    m.for_each(fn (k: &BigInt, v: &Int) {
        std::io::println(f"{std::string::from_int(k.v)} -> {std::string::from_int(*v)}");
    });
    m.for_each_mut(fn (k: &BigInt, v: &mut Int) {
        *v = *v * 2;
    });
    m.for_each(fn (k: &BigInt, v: &Int) {
        std::io::println(f"{std::string::from_int(k.v)} -> {std::string::from_int(*v)}");
    });
}
