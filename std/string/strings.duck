use go "strings";
use go "strconv";
use go "unicode/utf8";

/// these are the main string utilities of the duck std library
extend String with impl {
    fn split_arr(sep: String) -> String[] {
        return go {
            $ = strings.Split(self, sep)
        }
    }

    fn split(sep: String) -> ::col::ArrayList<String> {
        return ArrayList::from_array<String>(self.split_arr(sep));
    }

    fn split_lines_arr() -> String[] {
        let lines: String[] = go {
            $ = strings.Split(self, "\n")
        };

        return lines;
    }

    fn split_lines() -> ::col::ArrayList<String> {
        return ArrayList::from_array<String>(self.split_lines_arr());
    }

    /// returns the length of the string self
    fn len() -> Int {
        let len_var: Int = 0;
        go {
            len_var = len(self)
        }

        return len_var;
    }

    /// returns the count of actual utf8 runes in the string
    fn count() -> Int {
        let count: Int = 0;
        go {
            count = utf8.RuneCountInString(self)
        }
        return count;
    }

    /// returns if the string is empty
    fn is_empty() -> Bool {
        return self.len() == 0;
    }

    /// returns if the string contains the given substr
    fn contains(substr: String) -> Bool {
        let exists: Bool = false;
        go {
            exists = strings.Contains(self, substr)
        }
        return exists;
    }

    /// returns if the string starts with given prefix
    fn starts_with(prefix: String) -> Bool {
        let res: Bool = false;
        go {
            res = strings.HasPrefix(self, prefix)
        }
        return res;
    }

    /// returns if the string ends with the given suffix
    fn ends_with(suffix: String) -> Bool {
        let res: Bool = false;
        go {
            res = strings.HasSuffix(self, suffix)
        }
        return res;
    }

    /// returns the index of the given substr or .none if not found
    fn index_of(substr: String) -> Int | .none {
        let idx: Int = -1;
        go {
            idx = strings.Index(self, substr)
        }

        if (idx == -1) {
            return .none;
        }

        return idx;
    }

    /// returns the string in uppercase
    fn to_upper() -> String {
        let s: String = "";
        go {
            s = strings.ToUpper(self)
        }
        return s;
    }

    /// returns the string in lowercase
    fn to_lower() -> String {
        let s: String = "";
        go {
            s = strings.ToLower(self)
        }
        return s;
    }

    fn trim_left(cutset: String) -> String {
        return go {
            $ = strings.TrimLeft(self, cutset)
        } as String;
    }

    fn trim_right(cutset: String) -> String {
        return go {
            $ = strings.TrimRight(self, cutset)
        } as String;
    }

    /// returns the string with trimmed space at the beginning and end of the string
    fn trim() -> String {
        let s: String = "";
        go {
            s = strings.TrimSpace(self)
        }
        return s;
    }

    /// returns the string with given old_s replaced with given new_s
    fn replace(old_s: String, new_s: String) -> String {
        let s: String = "";
        go {
            s = strings.ReplaceAll(self, old_s, new_s)
        }
        return s;
    }

    /// returns a substring of the string
    fn substring(start: Int, end: Int) -> String | .err_out_of_bounds {
        let s: String = "";
        let err: Bool = false;

        go {
            if start < 0 || end > len(self) || start > end {
                err = true
            } else {
                s = (self)[start:end]
            }
        }

        if (err) {
            return .err_out_of_bounds;
        }
        return s;
    }

    /// returns the string repeated
    fn repeat(count: Int) -> String {
        let s: String = "";
        go {
            s = strings.Repeat(self, count)
        }
        return s;
    }

    /// returns the string as a int or .err_parsing if couldn't parse to int
    fn to_int() -> Int | .err_parsing {
        let res: Int = 0;
        let err_occurred: Bool = false;
        go {
            i, err := strconv.Atoi(self)
            if err != nil {
                err_occurred = true
            } else {
                res = i
            }
        }

        if (err_occurred) {
            return .err_parsing;
        }

        return res;
    }

    /// returns a byte array of the string
    fn to_bytes() -> Byte[] {
        go {
             $ = []byte(self)
        } as Byte[]
    }

    fn bold() -> String {
        f"\o033[1m{self}\o033[0m"
    }

    fn italic() -> String {
        f"\o033[3m{self}\o033[0m"
    }

    fn underline() -> String {
        f"\o033[4m{self}\o033[0m"
    }

    fn red() -> String {
        f"\o033[31m{self}\o033[0m"
    }

    fn green() -> String {
        f"\o033[32m{self}\o033[0m"
    }

    fn yellow() -> String {
        f"\o033[33m{self}\o033[0m"
    }

    fn blue() -> String {
        f"\o033[34m{self}\o033[0m"
    }

    fn magenta() -> String {
        f"\o033[35m{self}\o033[0m"
    }

    fn cyan() -> String {
        f"\o033[36m{self}\o033[0m"
    }

    fn gray() -> String {
        f"\o033[37m{self}\o033[0m"
    }

    fn white() -> String {
        f"\o033[97m{self}\o033[0m"
    }

    fn on_red() -> String {
        f"\o033[41m{self}\o033[0m"
    }

    fn on_green() -> String {
        f"\o033[42m{self}\o033[0m"
    }

    fn on_yellow() -> String {
        f"\o033[43m{self}\o033[0m"
    }

    fn on_blue() -> String {
        f"\o033[44m{self}\o033[0m"
    }

    fn on_magenta() -> String {
        f"\o033[45m{self}\o033[0m"
    }

    fn on_cyan() -> String {
        f"\o033[46m{self}\o033[0m"
    }

    fn on_gray() -> String {
        f"\o033[47m{self}\o033[0m"
    }

    fn on_white() -> String {
        f"\o033[107m{self}\o033[0m"
    }

    fn rgb(r: Int, g: Int, b: Int) -> String {
        f"\o033[38;2;{r.to_string()};{g.to_string()};{b.to_string()}m{self}\o033[0m"
    }

    fn on_rgb(r: Int, g: Int, b: Int) -> String {
        f"\o033[48;2;{r.to_string()};{g.to_string()};{b.to_string()}m{self}\o033[0m"
    }
}

fn to_upper(s: String) -> String {
    let res: String = "";
    go {
        res = strings.ToUpper(s)
    }
    return res;
}

test "strings: to_upper" {
    let x: String = "Hallo, Welt"->to_upper();
    if (x != "HALLO, WELT") {
        go {
            panic("expected x to be 'HALLO, WELT' but it wasn't")
        }
    }
}

fn to_lower(s: String) -> String {
    let res: String = "";
    go {
        res = strings.ToLower(s)
    }
    return res;
}

fn from_int(x: Int) -> String {
    let res: String = "";
    go {
        res = strconv.Itoa(x)
    }
    return res;
}

/// returns x in uppercase
fn to_int(x: String) -> Int {
    let res: Int = 0;
    go {
        tmp, _ := strconv.Atoi(x)
        res = tmp
    }
    return res;
}

fn from_bool(x: Bool) -> String {
    let res: String = "";
    go {
        res = strconv.FormatBool(x)
    }
    return res;
}
