use go "strings";
use go "strconv";
use go "unicode/utf8";

use ::col::{empty_array_list, ArrayList};

extend String with impl {
    fn len() -> Int {
        let len_var: Int = 0;
        go {
            len_var = len(self)
        }

        return len_var;
    }

    fn count() -> Int {
        let count: Int = 0;
        go {
            count = utf8.RuneCountInString(self)
        }
        return count;
    }

    fn is_empty() -> Bool {
        return self.len() == 0;
    }

    fn contains(substr: String) -> Bool {
        let exists: Bool = false;
        go {
            exists = strings.Contains(self, substr)
        }
        return exists;
    }

    fn starts_with(prefix: String) -> Bool {
        let res: Bool = false;
        go {
            res = strings.HasPrefix(self, prefix)
        }
        return res;
    }

    fn ends_with(suffix: String) -> Bool {
        let res: Bool = false;
        go {
            res = strings.HasSuffix(self, suffix)
        }
        return res;
    }

    fn index_of(substr: String) -> Int | .none {
        let idx: Int = -1;
        go {
            idx = strings.Index(self, substr)
        }

        if (idx == -1) {
            return .none;
        }

        return idx;
    }

    fn to_upper() -> String {
        let s: String = "";
        go {
            s = strings.ToUpper(self)
        }
        return s;
    }

    fn to_lower() -> String {
        let s: String = "";
        go {
            s = strings.ToLower(self)
        }
        return s;
    }

    fn trim() -> String {
        let s: String = "";
        go {
            s = strings.TrimSpace(self)
        }
        return s;
    }

    fn replace(old_s: String, new_s: String) -> String {
        let s: String = "";
        go {
            s = strings.ReplaceAll(self, old_s, new_s)
        }
        return s;
    }

    fn substring(start: Int, end: Int) -> String | .err_out_of_bounds {
        let s: String = "";
        let err: Bool = false;

        go {
            if start < 0 || end > len(self) || start > end {
                err = true
            } else {
                s = (self)[start:end]
            }
        }

        if (err) {
            return .err_out_of_bounds;
        }
        return s;
    }

    fn repeat(count: Int) -> String {
        let s: String = "";
        go {
            s = strings.Repeat(self, count)
        }
        return s;
    }

    fn to_int() -> Int | .err_parsing {
        let res: Int = 0;
        let err_occurred: Bool = false;
        go {
            i, err := strconv.Atoi(self)
            if err != nil {
                err_occurred = true
            } else {
                res = i
            }
        }

        if (err_occurred) {
            return .err_parsing;
        }

        return res;
    }

    fn to_bytes() -> Int[] {
        let bytes: Int[] = [];
        go {
             b := []byte(self)
             bytes = *(*[]int)(unsafe.Pointer(&b))
        }
        return bytes;
    }
}

fn to_upper(s: String) -> String {
    let res: String = "";
    go {
        res = strings.ToUpper(s)
    }
    return res;
}

test "strings: to_upper" {
    let x: String = "Hallo, Welt"->to_upper();
    if (x != "HALLO, WELT") {
        go {
            panic("expected x to be 'HALLO, WELT' but it wasn't")
        }
    }
}

fn to_lower(s: String) -> String {
    let res: String = "";
    go {
        res = strings.ToLower(s)
    }
    return res;
}

fn from_int(x: Int) -> String {
    let res: String = "";
    go {
        res = strconv.Itoa(x)
    }
    return res;
}

fn to_int(x: String) -> Int {
    let res: Int = 0;
    go {
        tmp, _ := strconv.Atoi(x)
        res = tmp
    }
    return res;
}

fn from_bool(x: Bool) -> String {
    let res: String = "";
    go {
        res = strconv.FormatBool(x)
    }
    return res;
}
