use go "path/filepath";
use go "path";
use ::col::{Iter, ArrayList};
use ::result::{Result};

struct DirEntry {
    file_path: FilePath,
    is_dir: Bool,
}

[auto(ToJson, FromJson, Eq)]
struct FilePath {
    path_ref: String,
    last_error: String | .none,
} impl {
    static fn new(p: String) -> FilePath {
        return FilePath {
            path_ref: go {
                $ = filepath.Clean(p)
            } as String,
            last_error: .none,
        };
    }

    /// returns the paths to all directories at self
    fn iter_dirs() -> Iter<FilePath> {
        const empty_iter = Iter::empty<FilePath>();
        if (self.failed()) {
            return empty_iter;
        }

        let entries = ArrayList::new<FilePath>();
        const to_dir_entry = fn (path_ref: String) -> FilePath {
            FilePath {
                path_ref: path_ref,
                last_error: .none,
            }
        };

        let error = false;
        go {
            files, err := os.ReadDir((*self).path_ref)
            if err != nil {
            	error_msg := err.Error()
                (*self).last_error = &error_msg
                return empty_iter
            }

            for _, f := range files {
                child_path := filepath.Join((*self).path_ref, f.Name())
                entries.push(to_dir_entry(child_path))
            }
        }

        return entries.iter()
            .map<FilePath>(fn (entry) { *entry })
    }

    /// Recursively finds all files within this directory
    fn walk() -> Iter<FilePath> {
        if (self.failed()) {
            return Iter::empty<FilePath>();
        }

        let file_paths = ArrayList::new<String>();
        let root = self.path_ref;

        go {
            filepath.Walk(root, func(p string, info os.FileInfo, err error) error {
                if err != nil {
                    return nil
                }

                file_paths.elems = append(file_paths.elems, p)
                return nil
            })
        }

        let current_idx = 0;

        return Iter::from<FilePath>(mut fn() -> FilePath | .no_next_elem {
            if (current_idx >= file_paths.len()) {
                return .no_next_elem;
            }

            const fp = file_paths.get(current_idx);
            if (fp.is_some()) {
                current_idx = current_idx + 1;
                return FilePath {
                    path_ref: fp.unwrap(),
                    last_error: .none,
                };
            }

            return .no_next_elem
        });
    }

    /// Recursively finds all files within this directory, skipping directory entries.
    fn walk_files() -> Iter<FilePath> {
        if (self.failed()) {
            return Iter::empty<FilePath>();
        }

        let file_paths = ArrayList::new<String>();
        let root = self.path_ref;

        go {
            filepath.Walk(root, func(p string, info os.FileInfo, err error) error {
                if err != nil {
                    return nil
                }

                if !info.IsDir() {
                    file_paths.elems = append(file_paths.elems, p)
                }
                return nil
            })
        }

        let current_idx = 0;

        return Iter::from<FilePath>(mut fn() -> FilePath | .no_next_elem {
            if (current_idx >= file_paths.len()) {
                return .no_next_elem;
            }

            const fp = file_paths.get(current_idx);
            if (fp.is_some()) {
                current_idx = current_idx + 1;
                return FilePath {
                    path_ref: fp.unwrap(),
                    last_error: .none,
                };
            }

            return .no_next_elem
        });
    }

    fn failed() -> Bool {
        return self.last_error != .none;
    }

    fn join(part: String) -> FilePath {
        let new_path = go {
            $ = filepath.Join((*self).path_ref, part)
        } as String;

        return FilePath {
            path_ref: new_path,
            last_error: self.last_error,
        }
    }

    fn parent() -> FilePath {
        let parent_path = go {
            $ = filepath.Dir((*self).path_ref)
        } as String;

        return FilePath {
            path_ref: parent_path,
            last_error: self.last_error,
        };
    }

    fn filename() -> String {
        return go {
            $ = filepath.Base((*self).path_ref)
        } as String;
    }

    fn extension() -> String {
        return go {
            $ = filepath.Ext((*self).path_ref)
        } as String;
    }

    fn ensure_dir() -> &FilePath {
        if (self.failed()) {
            return self;
        }

        go {
            dir := filepath.Dir((*self).path_ref)
            err := os.MkdirAll(dir, 0755)
            if err != nil {
            	s := err.Error()
               	(*self).last_error = &s
            }
        }

        return self;
    }

    /// writes to a .tmp file, then renames to target - prevennts file corruption if a crash occurs while writing
    fn write(content: String) -> &mut FilePath {
        if (self.failed()) {
            return self;
        }

        let tmp_path = f"{self.path_ref}.tmp";
        go {
            err := os.WriteFile(tmp_path, []byte(content), 0644)
            if err != nil {
	           	s := err.Error()
               	(*self).last_error = &s
               	return self
            }

            err = os.Rename(tmp_path, (*self).path_ref)
            if err != nil {
                s := err.Error()
               	(*self).last_error = &s
               	return self
            }
        }

        return self
    }

    mut fn delete() -> &mut FilePath {
        if (self.failed()) {
            return self;
        }

        go {
            err := os.Remove((*self).path_ref)
            if err != nil {
                s := err.Error()
                (*self).last_error = &s
            }
        }

        return self;
    }

    mut fn rename(new_path: String) -> &FilePath {
        if (self.failed()) {
            return self;
        }

        go {
            if err := os.Rename((*self).path_ref, new_path); err != nil {
            	s := err.Error()
               	(*self).last_error = &s
            }
        }

        self.path_ref = new_path;

        return self;
    }

    fn read() -> Result<String, ()> {
        const err_result = Result::err<String, ()>(());
        if (self.failed()) {
            return err_result;
        }

        const content = go {
            bs, err := os.ReadFile((*self).path_ref)
            if err != nil {
               	return err_result
            }

            $ = string(bs)
        } as String;

        return Result::ok<String, ()>(content);
    }

    fn size() -> Int | .err {
        return go {
            s, err := os.Stat((*self).path_ref)
            if err != nil {
               	return &Tag__err {}
            }

            tmp := int(s.Size())
            return &tmp
        } as Int;
    }

    fn exists() -> Bool {
        if (self.failed()) {
            return false;
        }

        return go {
            _, err := os.Stat((*self).path_ref)
            $ = !os.IsNotExist(err)
        } as Bool;
    }

    fn expect(msg: String) -> String {
        match self.last_error {
            String @err => {
                std::error::panic(f"{msg}: {err}")
            },
            .none => return self.path_ref,
        }
    }
}
