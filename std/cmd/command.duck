use ::col::{ArrayList};
use ::result::Result;
use go "os/exec";
use go "os";

struct Process {
    inner: &go "os.Process"
} impl {
    fn kill() -> .err | .none {
        go {
            err := (*self).inner.Kill()
            if err != nil {
            	return Tag__err {}
            }

            return Tag__none {}
        } as !
    }
}

struct Cmd {
    program: String,
    cmd_args: ::col::ArrayList<String>,
    cwd: String | .none,
} impl {
    static fn new(
        program: String
    ) -> Cmd {
        return Cmd {
            program: program,
            cmd_args: ::col::ArrayList::new<String>(),
            cwd: .none,
        }
    }

    mut fn dir(p: String) -> &mut Cmd {
        self.cwd = p;
        return self;
    }

    static fn exec(
        command: String,
    ) -> Result<
        { stdout: String, stderr: String, exitcode: Int },
        ()
    >{
        const splitted: String[] = go {
            $ = strings.Split(command, " ")
        };

        const args: String[] = go {
            $ = splitted[1:]
        };

        return Cmd::new(splitted[0])
           .args(args)
           .run();
    }

    mut fn arg(arg: String) -> &mut Cmd {
        self.cmd_args.push(arg);
        return self;
    }

    mut fn args(_args: String[]) -> &mut Cmd {
        for (arg in _args.iter()) {
            self.cmd_args.push(*arg);
        }
        return self;
    }

    fn spawn() -> Process | .err {
        let process: &go "os.Process" = go {
            cmd := exec.Command((*self).program, (*self).cmd_args.elems...)
            if dir, ok := (*self).cwd.(string); ok {
            	cmd.Dir = dir
            }

            err := cmd.Start()
            if err != nil {
            	return Tag__err {}
            }

            $ = cmd.Process
        };

        return Process { inner: process }
    }

    fn run() -> Result<
        { stdout: String, stderr: String, exitcode: Int },
        ()
    > {
        let output = { stdout: "", stderr: "", exitcode: 0 };
        const err_res = Result::err<typeof output, ()>(());

        go {
            cmd := exec.Command((*self).program, (*self).cmd_args.elems...)

            if dir, ok := (*self).cwd.(string); ok {
            	cmd.Dir = dir
            }

            var outBuf bytes.Buffer
            var errBuf bytes.Buffer

            cmd.Stdout = &outBuf;
            cmd.Stderr = &errBuf;

            err := cmd.Run()
            if err != nil {
                if exitErr, ok := err.(*exec.ExitError); ok {
                    output.Setstderr(string(exitErr.Stderr))
                    output.Setexitcode(exitErr.ExitCode())
                    goto err_program_exited_017171
                }

                // todo: return go error
                return err_res
            }

            output.Setstdout(outBuf.String())
            output.Setstderr(errBuf.String())
            err_program_exited_017171:
        }

        return Result::ok<typeof output, ()>(output);
    }

    fn run_and_forget() -> .err | .none {
        go {
            cmd := exec.Command((*self).program, (*self).cmd_args.elems...)

            if dir, ok := (*self).cwd.(string); ok {
               	cmd.Dir = dir
            }

            err := cmd.Run()
            if err != nil {
                return Tag__err { }
            }

            return Tag__none {}
        }
    }
}
