use go "net/http";
use go "slices";
use go "reflect";
use go "unsafe";

type RenderedTsx = (
    String,
    String,
);

type TsxComponent<P> = fn (props: P) -> RenderedTsx;

fn with_react(
    rendered_tsx: RenderedTsx
) -> String {
    let layout: String = f"
        <!DOCTYPE html>
        <html>
            <body>
                <script type='module'>
                    import \{ h, render } from 'https://esm.sh/preact';
                    import \{ useState } from 'https://esm.sh/preact/hooks';
                    import htm from 'https://esm.sh/htm';

                    const html = htm.bind(h);

                    {rendered_tsx.1}
                    render(html`<$\{{rendered_tsx.0}} />`, document.body);
                </script>
            </body>
        </html>
    ";

    return layout;
}

fn serve_component<P>(
    route: String,
    tsx_component: TsxComponent<P>,
    prop_supplier: fn () -> P,
) {
    let x = with_react;
    go {
        var h = x;
        http.HandleFunc(route.as_dgo_string(), func (w http.ResponseWriter, r *http.Request) {
            var tsx = tsx_component(prop_supplier());
            w.Write([]byte(h(tsx).as_dgo_string()))
        })
    }
}

fn serve_string(
    route: String,
    tsx_component: String,
) {
    go {
        http.HandleFunc(route.as_dgo_string(), func (w http.ResponseWriter, r *http.Request) {
            w.Write([]byte(tsx_component.as_dgo_string()))
        })
    }
}

fn listen(port: Int) {
    go {
        http.ListenAndServe(fmt.Sprintf(":%d", port.as_dgo_int()), nil);
    }
}

fn render(renderer: Html) -> String {
    go {
	    env := TemplEnv{[]string{}, []RenderCall{}}
		res := renderer(&env)

		prelude := `
            <script type="module">
            import { h, render } from "https://esm.sh/preact";
            import { useState } from "https://esm.sh/preact/hooks";
            import htm from "https://esm.sh/htm";

            // Initialize htm with Preact
            const html = htm.bind(h);
        `

        for _, e := range env.ClientComponents {
            prelude += e
            prelude += "\n"
        }

        for _, e := range env.RenderCalls {
            prelude += fmt.Sprintf("document.querySelectorAll(\"[duckx-render=\\\"%s\\\"]\").forEach(e => render(html`%s`, e))", e.Id, e.Jsx)
            prelude += "\n"
        }

        prelude += "\n</script>"

		return ConcDuckString { res + prelude }
    }
}
