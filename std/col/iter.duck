use ::col::{ArrayList};

struct Iter<T> {
    next_fn: mut fn() -> T | .no_next_elem,
} impl {
    static fn from<T>(next_fn: mut fn() -> T | .no_next_elem) -> Iter<T> {
        return Iter<T> {
            next_fn: next_fn,
        }
    }

    static fn empty<T>() -> Iter<T> {
        return Iter<T> {
            next_fn: fn () -> T | .no_next_elem {
                return .no_next_elem;
            }
        }
    }

    static fn range(start_inclusive: Int, end_exclusive: Int) -> Iter<Int> {
        Iter::from<Int>(mut fn() {
            if (start_inclusive >= end_exclusive) {
                return .no_next_elem;
            }

            const to_yield = start_inclusive;
            start_inclusive = start_inclusive + 1;
            to_yield
        })
    }

    static fn count_from(start: Int) -> Iter<Int> {
        Iter::from<Int>(mut fn() {
            const to_yield = start;
            start = start + 1;
            return to_yield;
        })
    }

    mut fn rev() -> Iter<T> {
        let stack = ::col::ArrayList::new<T>();

        Iter::from<T>(mut fn () {
            while (true) {
                match self.next_fn() {
                    T @t => stack.push(t),
                    .no_next_elem => break,
                }
            }

            const maybe_next = stack.pop();
            if (maybe_next.is_some()) {
                return maybe_next.unwrap();
            } else {
                return .no_next_elem;
            }
        })
    }

    mut fn next() -> T | .no_next_elem {
        return match self.next_fn() {
            T @x => x,
            .no_next_elem => .no_next_elem,
        };
    }

    mut fn for_each(f: fn(T)) {
        while (true) {
            let next = self.next_fn();
            match next {
                T @str => f(str),
                .no_next_elem => return
            }
        }
    }

    mut fn chain(other_iters: Iter<T>[] | Iter<T>) -> Iter<T> {
        let remaining_iters = ArrayList::from_array<Iter<T>>(match other_iters {
            Iter<T>[] @iters => iters,
            Iter<T> @iter => [iter],
        });

        let current_iter = self;

        const next_fn = mut fn () -> T | .no_next_elem {
            while (true) {
                const next_elem = current_iter.next_fn();
                match next_elem {
                    T @value => return value,
                    .no_next_elem => {},
                };

                if (remaining_iters.len() > 0) {
                    const next_iter = remaining_iters.pop();
                    match next_iter.inner {
                        ::opt::Some<Iter<T>> @some => {
                            current_iter = &mut some.value;
                            continue;
                        },
                        .none => return .no_next_elem,
                    }
                }

                return .no_next_elem;
            }

            return .no_next_elem;
        };

        return Iter::from<T>(next_fn)
    }

    mut fn map<U>(apply: fn(T) -> U) -> Iter<U> {
        const next_fn = mut fn () -> U | .no_next_elem {
            return match self.next_fn() {
                T @t => apply(t),
                .no_next_elem => .no_next_elem,
            };
        };

        Iter::from<U>(next_fn)
    }

    mut fn skip_while(predicate: fn(T) -> Bool) -> Iter<T> {
        const next_fn = mut fn () -> T | .no_next_elem {
            while (true) {
                match self.next_fn() {
                    T @t => if (predicate(t)) {
                            continue;
                        } else {
                            return t;
                        },
                    .no_next_elem => return .no_next_elem,
                };
            }
            std::error::unreachable("skip_while");
        };

        Iter::from<T>(next_fn)
    }

    mut fn take_while(predicate: fn(T) -> Bool) -> Iter<T> {
        const next_fn = mut fn () -> T | .no_next_elem {
            while (true) {
                match self.next_fn() {
                    T @t => if (predicate(t)) {
                            return t
                        } else {
                            return .no_next_elem
                        },
                    .no_next_elem => return .no_next_elem,
                };
            }
            std::error::unreachable("take_while");
        };

        Iter::from<T>(next_fn)
    }

    mut fn filter(predicate: fn(T) -> Bool) -> Iter<T> {
        const next_fn = mut fn () -> T | .no_next_elem {
            while (true) {
                match self.next_fn() {
                    T @t => {
                        if (predicate(t)) {
                            return t;
                        } else {
                            continue;
                        }
                    },
                    .no_next_elem => return .no_next_elem,
                };
            }
            std::error::unreachable("filter");
        };

        Iter::from<T>(next_fn)
    }

    mut fn skip(amount: Int) -> Iter<T> {
        let to_skip = amount;
        const next_fn = mut fn () -> T | .no_next_elem {
            while (true) {
                let next = self.next_fn();
                if (to_skip > 0) {
                    to_skip = to_skip - 1;
                    continue;
                }

                return match next {
                    T @t => t,
                    .no_next_elem => return .no_next_elem,
                };
            }
            std::error::unreachable("skip");
        };

        Iter::from<T>(next_fn)
    }

    mut fn take(amount: Int) -> Iter<T> {
        let to_take = 0;
        const next_fn = mut fn () -> T | .no_next_elem {
            let next = self.next_fn();
            if (to_take >= amount) {
                return .no_next_elem;
            }

            to_take = to_take + 1;
            return match next {
                T @t => t,
                .no_next_elem => return .no_next_elem,
            };
        };

        Iter::from<T>(next_fn)
    }

    mut fn indexed() -> Iter<(Int, T)> {
        let index = 0;
        let next_fn = mut fn () -> (Int, T) | .no_next_elem {
            const next = match self.next_fn() {
                T @t => t,
                .no_next_elem => return .no_next_elem,
            };

            const index_to_return = index;
            index = index + 1;
            return (index_to_return, next);
        };

        return Iter::from<(Int, T)>(next_fn);
    }

    mut fn fold<U>(init: U, f: mut fn(acc: &mut U, elem: T) -> U) -> U {
        while (true) {
            const elem = match (self.next()) {
                T @t => t,
                .no_next_elem => break,
            };

            f(&mut init, elem);
        }
        return init;
    }

    mut fn reduce(f: mut fn(acc: &mut T, elem: T)) -> ::opt::Opt<T> {
        let first = match (self.next()) {
            T @t => t,
            .no_next_elem => return ::opt::Opt::none<T>(),
        };

        while (true) {
            const elem = match (self.next()) {
                T @t => t,
                .no_next_elem => break,
            };
            f(&mut first, elem);
        }

        return ::opt::Opt::some<T>(first);
    }

    mut fn into_list() -> ArrayList<T> {
        let arr = ArrayList::new<T>();
        while (true) {
            match self.next_fn() {
                T @elem => arr.push(elem),
                .no_next_elem => return arr,
            }
        }

        return arr;
    }

    mut fn count() -> UInt {
        let result = 0 as UInt;

        while (true) {
            match self.next_fn() {
                T => {
                    result = result + (1 as UInt);
                },
                .no_next_elem => break,
            }

        }

        result
    }

    mut fn find(f: fn(e: T) -> Bool) -> ::opt::Opt<T> {
        while (true) {
            match self.next_fn() {
                T @t => {
                    if (f(t)) {
                        return ::opt::Opt::some<T>(t);
                    }
                },
                .no_next_elem => break,
            }
        }
        return ::opt::Opt::none<T>();
    }

    mut fn any(f: fn(e: T) -> Bool) -> Bool {
        while (true) {
            match self.next_fn() {
                T @t => {
                    if (f(t)) {
                        return true;
                    }
                },
                .no_next_elem => break,
            }
        }
        false
    }

    mut fn all(f: fn(e: T) -> Bool) -> Bool {
        while (true) {
            match self.next_fn() {
                T @t => {
                    if (!f(t)) {
                        return false;
                    }
                },
                .no_next_elem => break,
            }
        }
        true
    }

    mut fn zip<U>(other: Iter<U>) -> Iter<(T, U)> {
        const new_fn = mut fn() -> (T, U) | .no_next_elem {
            match self.next_fn() {
                T @t => {
                    match other.next_fn() {
                        U @u => return (t, u),
                        .no_next_elem => .no_next_elem,
                    }
                },
                .no_next_elem => .no_next_elem,
            }
        };

        Iter::from<(T, U)>(new_fn)
    }
}
