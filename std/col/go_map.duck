struct GoMap<K, V> {
    inner: go "map[{K}]*{V}",
} impl {
    static fn new<K, V>() -> GoMap<K, V> {
        const go_map: go "map[{K}]*{V}" = go {
            $ = make(map[<<<K>>>]*<<<V>>>)
        };

        return GoMap<K, V> {
            inner: go_map,
        };
    }

    fn contains_key(k: K) -> Bool {
        go {
            _, ok := (*self).inner[k]
            $ = ok
        } as Bool
    }

    mut fn set(k: K, v: V) {
       go {
           (*self).inner[k] = &v
       }
    }

    fn get(k: &K) -> ::opt::Opt<&V> {
        const tag_none = ::opt::Opt::none<&V>();
        const x = go {
            val, ok := (*self).inner[*k]
            if ok {
               $ = val
            } else {
                return tag_none
            }
        } as &V;

        return ::opt::Opt::some<&V>(x);
    }

    mut fn get_mut(k: &K) -> ::opt::Opt<&mut V> {
        const tag_none = ::opt::Opt::none<&mut V>();

        const x = go {
            val, ok := (*self).inner[*k]
            if ok {
            	$ = val
            } else {
                return tag_none;
            }
       } as &mut V;

       return ::opt::Opt::some<&mut V>(x);
    }

    mut fn remove(k: &K) -> ::opt::Opt<V> {
        const tag_none = ::opt::Opt::none<V>();
        const x = go {
            key_deref := *k
            val, ok := (*self).inner[key_deref]
            if ok {
                delete((*self).inner, key_deref)
                $ = *val
            } else {
                return tag_none
            }
        } as V;

        return ::opt::Opt::some<V>(x)
    }
}
