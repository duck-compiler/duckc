use ::{Opt};

struct ArrayList<T> = {
    elems: T[]
} impl {
    mut fn push(new_elem: T) -> ArrayList<T> {
        go {
            (*self).elems = append((*self).elems, new_elem)
        }
        return *self;
    }

    mut fn pop() -> Opt<T> {
        let popped_val: Opt<T> = .none;
        go {
            if (len((*self).elems) > 0) {
                var index = len((*self).elems) - 1;
                popped_val = (*self).elems[index];
                (*self).elems = (*self).elems[:index];
            }
        }
        return popped_val;
    }

    fn get(
        index: Int
    ) -> None | T | "error: index out of bounds" {
        let index_out_of_bounds: "error: index out of bounds" = "error: index out of bounds";
        let elem: T | "none" = "none";
        go {
            if index < 0 || index >= (*self).len() {
                return index_out_of_bounds;
            }

            elem = (*self).elems[index]
        }
        return elem;
    }

    mut fn set(index: Int, value: T) -> ArrayList<T> {
        go {
            (*self).elems[index] = value
        }
        return *self;
    }

    mut fn remove(index: Int) -> ArrayList<T> {
        go {
            (*self).elems = append((*self).elems[:index], (*self).elems[index+1:]...)
        }
        return *self;
    }

    fn len() -> Int {
        let l: Int = 0;
        go {
            l = len((*self).elems);
        }
        return l;
    }

    fn is_empty() -> Bool {
        let empty: Bool = true;
        go {
            empty = len((*self).elems) == 0
        }
        return empty;
    }

    mut fn clear() -> ArrayList<T> {
        self.elems = [] as T[];
        return *self;
    }

    fn map<U>(f: fn(x: T) -> U) -> ArrayList<U> {
        let res: ArrayList<U> = empty_array_list<U>();
        go {
            for _, e := range (*self).elems {
                res.elems = append(res.elems, f(e))
            }
        }
        return res;
    }

    fn filter(f: fn(x: T) -> Bool) -> ArrayList<T> {
        let res: ArrayList<T> = empty_array_list<T>();
        go {
            for _, e := range (*self).elems {
                if f(e) {
                    res.elems = append(res.elems, e)
                }
            }
        }
        return res;
    }

    fn reduce<U>(f: fn(acc: U, x: T) -> U, initial_value: U) -> U {
        let acc: U = initial_value;
        go {
            for _, e := range (*self).elems {
                acc = f(acc, e)
            }
        }
        return acc;
    }

    fn for_each(f: fn(e: T) -> ()) {
        go {
            for _, e := range (*self).elems {
                f(e)
            }
        }
    }

    fn find(f: fn(x: T) -> Bool) -> T | "none" {
        let result: T | "none" = "none";
        go {
            for _, e := range (*self).elems {
                if f(e) {
                    result = e
                    break
                }
            }
        }
        return result;
    }

    fn find_index(
        predicate: fn(element: T) -> Bool
    ) -> Int | "none" {
        let result: Int | "none" = "none";
        go {
            for i, elem := range (*self).elems {
                if predicate(elem) {
                    result = i;
                    break
                }
            }
        }
        return result;
    }

};

fn empty_array_list<T>() -> ArrayList<T> {
    return ArrayList<T> {
        elems: [] as T[],
    };
}

fn array_of<T>(initial_elements: T[]) -> ArrayList<T> {
    return ArrayList<T> {
        elems: initial_elements
    };
}
