use ::opt::{Opt};

struct ArrayList<T> {
    elems: T[]
} impl {
    static fn new<T>() -> ArrayList<T> {
        ArrayList<T> {
            elems: [] as T[],
        }
    }

    static fn from_array<T>(initial_elements: T[]) -> ArrayList<T> {
        ArrayList<T> {
            elems: initial_elements
        }
    }

    mut fn push(new_elem: T) -> &mut ArrayList<T> {
        go {
            (*self).elems = append((*self).elems, new_elem)
        }
        return self;
    }

    mut fn pop() -> Opt<T> {
        if (self.len() > 0) {
            const value: T = go {
                var index = len((*self).elems) - 1;
                $ = (*self).elems[index];
                (*self).elems = (*self).elems[:index];
            } as T;

            return Opt::some<T>(value);
        }

        return Opt::none<T>();
    }

    fn get(
        index: Int
    ) -> Opt<T> {
        const tag_none = Opt::none<T>();
        const elem = go {
            if index < 0 || index >= (*self).len() {
                return tag_none;
            }

            $ = (*self).elems[index]
        } as T;
        return Opt::some<T>(elem);
    }

    mut fn set(index: Int, value: T) -> &mut ArrayList<T> {
        go {
            (*self).elems[index] = value
        }
        return self;
    }

    mut fn remove(index: Int) -> &mut ArrayList<T> {
        go {
            (*self).elems = append((*self).elems[:index], (*self).elems[index+1:]...)
        }
        return self;
    }

    fn len() -> Int {
        let l: Int = 0;
        go {
            l = len((*self).elems);
        }
        return l;
    }

    fn is_empty() -> Bool {
        let empty: Bool = true;
        go {
            empty = len((*self).elems) == 0
        }
        return empty;
    }

    mut fn clear() -> &mut ArrayList<T> {
        self.elems = [] as T[];
        return self;
    }

    fn map<U>(f: fn(x: T) -> U) -> ArrayList<U> {
        let res: ArrayList<U> = ArrayList::new<U>();
        go {
            for _, e := range (*self).elems {
                res.elems = append(res.elems, f(e))
            }
        }
        return res;
    }

    fn filter(f: fn(x: T) -> Bool) -> ArrayList<T> {
        let res: ArrayList<T> = ArrayList::new<T>();
        go {
            for _, e := range (*self).elems {
                if f(e) {
                    res.elems = append(res.elems, e)
                }
            }
        }
        return res;
    }

    fn reduce<U>(f: fn(acc: U, x: T) -> U, initial_value: U) -> U {
        let acc: U = initial_value;
        go {
            for _, e := range (*self).elems {
                acc = f(acc, e)
            }
        }
        return acc;
    }

    fn for_each(f: fn(e: T) -> ()) {
        go {
            for _, e := range (*self).elems {
                f(e)
            }
        }
    }

    fn find(f: fn(x: T) -> Bool) -> T | .none {
        let result: T | .none = .none;
        go {
            for _, e := range (*self).elems {
                if f(e) {
                    result = e
                    break
                }
            }
        }
        return result;
    }

    fn contains(something: T) -> Bool {
        let result = false;

        go {
            for _, e := range (*self).elems {
                if e == something {
                    result = true
                    break
                }
            }
        }

        return result;
    }

    fn any(f: fn(x: T) -> Bool) -> Bool {
        let result = false;

        go {
            for _, e := range (*self).elems {
                if f(e) {
                    result = true
                    break
                }
            }
        }

        return result;
    }

    fn find_index(
        predicate: fn(element: T) -> Bool
    ) -> Int | .none {
        let result: Int | .none = .none;
        go {
            for i, elem := range (*self).elems {
                if predicate(elem) {
                    result = i;
                    break
                }
            }
        }
        return result;
    }

    fn iter() -> ::col::Iter<&T> {
        let idx = 0;
        const f = mut fn() -> &T | .no_next_elem {
            if (idx >= self.len()) {
                return .no_next_elem;
            }
            const elem_to_ret = &self.elems[idx];
            idx = idx + 1;
            return elem_to_ret;
        };

        return ::col::Iter::from<&T>(f);
    }

    mut fn iter_mut() -> ::col::Iter<&mut T> {
        let idx = 0;
        const f = mut fn() -> &mut T | .no_next_elem {
            if (idx >= self.len()) {
                return .no_next_elem;
            }
            const elem_to_ret = &mut self.elems[idx];
            idx = idx + 1;
            return elem_to_ret;
        };

        return ::col::Iter::from<&mut T>(f);
    }

    fn as_ref() -> &T[] {
        return &self.elems;
    }

    mut fn as_mut() -> &mut T[] {
        return &mut self.elems;
    }

}
