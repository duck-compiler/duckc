use go "time";

use ::opt::Opt;

struct Channel<T> {
    inner: go "chan {T}"
} impl {
    static fn new<T>() -> Channel<T> {
        const go_chan: go "chan {T}" = go { $ = make(chan <<<T>>>) };
        Channel<T> {
            inner: go_chan,
        }
    }

    static fn buffered<T>(cap: Int) -> Channel<T> {
        const go_chan: go "chan {T}" = go {
            $ = make(chan <<<T>>>, int(cap))
        };

        Channel<T> {
            inner: go_chan,
        }
    }

    fn send(x: T) {
        go {
            (*self).inner <- x
        }
    }

    fn recv_block() -> T {
        go {
            return <-(*self).inner
        } as T
    }

    fn recv_timeout(duration: ::time::Duration) -> Opt<T> {
        const as_seconds = duration.as_seconds;

        let v: T;
        let is_nothing = false;

        go {
            select {
                case v = <- (*self).inner:
                case <-time.After(duration.raw_duration):
                    is_nothing = true
            }
        };

        if (!is_nothing) {
            Opt::some<T>(v)
        } else {
            Opt::none<T>()
        }
    }

    fn try_recv() -> Opt<T> {
        let v: T;
        let is_nothing = false;

        go {
            select {
                case v = <-(*self).inner:
                default:
                	is_nothing = true
            }
        };

        if (!is_nothing) {
            Opt::some<T>(v)
        } else {
            Opt::none<T>()
        }
    }
}
