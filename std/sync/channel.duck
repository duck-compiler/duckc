use go "time";

struct Channel<T> {
    inner: go "chan {T}"
} impl {
    static fn new<T>() -> Channel<T> {
        const go_chan: go "chan {T}" = go { $$$res$$$ = make(chan <<<T>>>) };
        Channel<T> {
            inner: go_chan,
        }
    }

    fn send(x: T) {
        go {
            (*self).inner <- x
        }
    }

    fn recv_block() -> T {
        go {
            return <-(*self).inner
        } as T
    }

    fn recv_timeout(duration: ::time::Duration) -> Opt<T> {
        const tag_none = .none;
        const as_seconds = duration.as_seconds;
        go {
            select {
                case v := <- (*self).inner:
                    return v
                case <-time.After(duration.raw_duration):
                    return tag_none
            }
        } as Opt<T>
    }

    fn try_recv() -> ::Opt<T> {
        const tag_none = .none;
        go {
            select {
                case v := <-(*self).inner:
                    return v
                default:
                    return tag_none
            }
        } as !
    }
}
