use ::error;
use ::opt::Opt;

struct Err<E> {
    err: E,
} impl {
    static fn from_go(go_err: go "error") -> Err<String> {
        let r: Err<String> = Err<String> {
            err: "",
        };
        go {
            r.err = go_err.Error()
        }

        return r
    }
}

struct Result<T, E> {
    value: T | Err<E>,
} impl {
    static fn ok<T, E>(value: T) -> Result<T, E> {
        Result<T, E> {
            value: value,
        }
    }

    static fn err<T, E>(err: E) -> Result<T, E> {
        Result<T, E> {
            value: Err<E> { err: err },
        }
    }

    static fn from_go<T>(go_err: go "error") -> Result<T, String> {
        Result::err<T, String>(Err::from_go(go_err).err)
    }

    static fn from_go_select<T>(
        value: T,
        go_err: go "error",
    ) -> Result<T, String> {
        if (go { $ = (go_err != nil) } as Bool) {
            Result<T, String> { value: Err::from_go(go_err) }
        } else {
            Result::ok<T, String>(value)
        }
    }

    static fn from_go_select_with_bool<T>(
        value: T,
        go_err: go "error",
        is_error: Bool
    ) -> Result<T, String> {
        if (is_error) {
            Result<T, String> { value: Err::from_go(go_err) }
        } else {
            Result::ok<T, String>(value)
        }
    }

    fn map<U>(f: mut fn(T) -> U) -> Result<U, E> {
        match (self.value) {
            T @value => Result::ok<U, E>(f(value)),
            Err<E> @e => Result::err<U, E>(e.err),
        }
    }

    fn map_err<U>(f: mut fn(E) -> U) -> Result<T, U> {
        match (self.value) {
            Err<E> @e => Result::err<T, U>(f(e.err)),
            T @value => Result::ok<T, U>(value),
        }
    }

    fn ok() -> Opt<T> {
        match (self.value) {
            T @value => Opt::some<T>(value),
            else => Opt::none<T>(),
        }
    }

    fn err() -> Opt<E> {
        match (self.value) {
            Err<E> @e => Opt::some<E>(e.err),
            else => Opt::none<E>(),
        }
    }

    fn if_ok(f: mut fn(&mut T) -> ()) -> Result<T, E> {
        match (self.value) {
            T @value => f(&mut value),
            Err<E> @err => {},
        };
        *self
    }

    fn if_err(f: mut fn(&mut E) -> ()) -> Result<T, E> {
        match (self.value) {
            T @value => {},
            Err<E> @e => f(&mut e.err),
        };
        *self
    }

    fn expect(msg: String) -> T {
        match (self.value) {
            T @value => value,
            else => error::panic(msg),
        }
    }

    fn expect_err(msg: String) -> E {
        match (self.value) {
            Err<E> @e => e.err,
            else => error::panic(msg),
        }
    }

    fn or_else(default_value: T) -> T {
        match self.value {
            T @value => value,
            else => default_value,
        }
    }

    fn or_else_get(default_supplier: mut fn() -> T) -> T {
        match self.value {
            T @value => value,
            else => default_supplier(),
        }
    }

    fn unwrap() -> T {
        match self.value {
            T @value => value,
            else => error::panic("called unwrap on Err"),
        }
    }

    fn unwrap_err() -> E {
        match self.value {
            Err<E> @e => e.err,
            else => error::panic("called unwrap_err on Ok"),
        }
    }
}
